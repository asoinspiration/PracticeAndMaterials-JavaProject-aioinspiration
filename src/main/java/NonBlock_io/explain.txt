NIO
有人称之为New I/O，原因在于它相对于之前的I/O类库时新增的。这是它的官方叫法。
但非阻塞I/O(Non-block I/O)更能体现NIO的特点。

NIO提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现。
这两种新增的通道都支持阻塞和非阻塞两种模式。一般来说，低负荷，低并发的应用程序可以选择同步阻塞I/O
以降低编程的复杂度；对于高负载，高并发的网络应用，需要使用NIO的非阻塞模式进行开发。

缓冲区Buffer
在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别，它包含一些要写入或者要读出的数据。
在面向流的I/O中，可以将数据直接写入或者将数据直接读到Stream对象中。
在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；
在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。
缓冲区实质上是一个数组。但是缓冲区不仅仅是一个数组，缓冲区提供了对数据结构化访问
以及维护读写位置(limit)等信息。
最常用的缓冲区ByteBuffer，它提供一组功能用于操作byte。还有其他的一些缓冲区 CharBuffer,ShortBuffer,IntBuffer,LongBuffer,FloatBuffer,DoubleBuffer。
每一个Buffer类都是Buffer接口的一个子实例。每一个Buffer类都有完全一样的操作，只是它们所处理的数据类型不一样，除了ByteBuffer。
因为大多数标准I/O操作都使用ByteBuffer，所以它在具有一般缓冲区的操作之外还提供了一些特有的操作，以方便网络读写。

通道Channel
Channel是一个通道，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，
流只是在一个方向上移动(一个流必须是InoutStream或OutputStream的子类)，而通道可以用于读，写或二者同时进行(全双工)。
因为Channel是全双工的，所以它可以比流更好地映射底层操作系统的API。特别是在UNIX网络编程模型中，底层操作系统的通道全都是全双工的，同时支持读写操作。
Channel可以分为两大类：用于网络读写的SelectableChannel和用于文件操作的FileChannel。

多路复用器Selector
多路复用器提供选择已经就绪的任务能力。Selector会不断地轮询注册在其上的Channel，
如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。
一个多路复用器Selector可以同时轮询多个Channel,由于jdk使用了epoll()代替了传统的select实现，
所以它并没有最大连接句柄1024/2048的限制。这也就意味着只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。

NIO优点总结
1,客户端发起的连接操作时异步的，可以通过在多路复用器注册OP_CONNECT等待后续结果，不需要像之前那样被同步阻塞。
2,SocketChannel的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样I/O通信线程就可以处理其他的链路，不需要同步等待这个链路可用。
3,线程模型的优化:由于JDK的Selector在Linux等主流操作系统上通过epoll实现，它没有连接句柄数的限制(只受限于操作系统的最大句柄数或者对单个线程的句柄限制),这意味着一个Selector新城可以同时处理成千上万个客户端连接，
而且性能不会随着客户端的增加而线性下降。因此，它非常适合做高性能，高负载的网络服务器。

（本例没有完整的处理网络的半包读写）
