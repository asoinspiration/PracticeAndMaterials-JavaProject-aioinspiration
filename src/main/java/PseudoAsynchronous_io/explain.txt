伪异步I/O
采用线程池和任务队列可以实现一种叫伪异步的I/O通信框架。
后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M；
线程池最大线程数N的比例关系，其中M远大于N。通过线程池可以 灵活地调配
线程资源，设置线程最大值，可以防止海量并发接入导致资源耗尽。

当有新的客户接入时，将客户的Socket封装成一个Task(该任务实现java.lang.Runnable接口)
投递到后端的线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程，
对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，
因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。

伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程
造成的线程资源耗尽问题。但是对于底层的通信依然采用同步阻塞模型，因此无法从
根本上解决问题。

弊端分析
java InputStream API说明：This method blocks until input data is available, end of file is detected, or an exception is thrown.
当对Socket 的输入流进行读取操作的时候.它会一直阻塞下去，直到发生三件事：1 有数据可读；2 可用数据已经读取完毕；
3 发生空指针或者I/O异常。
这意味着当对方发送请求或应答消息比较缓慢，或者网络传输较慢是，读取输入流一方的通信将被长时间阻塞，
如果对方要60s才能将数据发送完成，读取一方的I/O线程也将会被同步阻塞60s，在此期间，其他接入消息只能在消息队列中排队。

当调用OutputStream的write方法写输出流的时候，它将会被阻塞，直到所有所有要发送的字节全部写入完毕，或者发生异常。
TCP/IP中，当消息的接收方处理缓慢的时候，将不能及时地从TCP缓冲区读取数据，这将会导致发送方的TCP window size 不断减少，直到为0，
双方处于Keep-Alive状态，消息发送方将不能再向TCP缓冲区写入消息，这时如果采用的时同步阻塞I/O，write操作将会被无限期阻塞，
直到window size 大于0 或者发生I/O异常。

（本例没有完整的处理网络的半包读写）